/*Generated by DSLFORGE*/

grammar Domainmodel;

options {
  language=JavaScript;
  output=AST;
  ASTLabelType=CommonTree;
}

@lexer::header {
}

@parser::header {
}




rule_DomainModel:
	elements+=rule_AbstractElement* EOF!




rule_AbstractElement:
	rule_PackageDeclaration | rule_Type | rule_Import;




rule_Import:
	'import' importednamespace=rule_QualifiedNameWithWildcard;




rule_PackageDeclaration:
	'package' name=rule_QualifiedName '{'
		elements+=rule_AbstractElement*
	'}';




rule_Type:
	rule_Entity | rule_DataType;




rule_DataType:
	'datatype' name=ID;




rule_Entity:
	'entity' name=ID ('extends' supertype=ID)? '{'
		features+=rule_Feature*
	'}';




rule_Feature:
	rule_StructuralFeature | rule_Operation;




rule_StructuralFeature:
	rule_Attribute | rule_Reference;




rule_Attribute:
	name=ID ':' type=rule_TypeRef;




rule_Reference:
	'ref' name=ID ':' type=rule_TypeRef ('opposite' opposite=ID)?;




rule_Operation:
	visibility=rule_Visibility? 'op' name=ID '(' (params+=rule_Parameter (',' params+=rule_Parameter)*)? ')' ':' type=rule_TypeRef;




rule_Parameter:
	name=ID type=rule_TypeRef;




rule_TypedElement:
	rule_Feature | rule_Parameter;




rule_TypeRef:
	referenced=ID multi='*'?;



	
rule_QualifiedName:
  rule_ValidID ('.' rule_ValidID)*;




rule_QualifiedNameWithWildcard :
	rule_QualifiedName  '.' '*';




rule_ValidID:
	ID;


rule_Visibility:
	public='public' | private='private' | protected='protected';


ID : ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* ;

STRING : ('"' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'"')))* '"'|'\'' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'\'')))* '\'');

COMMENT : ('/*' .* '*/' | '//' ~('\r' | '\n')*)   { $channel = HIDDEN; } ;

WS:  (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;} ;

//NUMBER: INT ('.' INT)?;

INT: ('0'..'9')+;

