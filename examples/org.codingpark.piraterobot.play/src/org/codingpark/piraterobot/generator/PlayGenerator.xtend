/*
 * generated by Xtext
 */
package org.codingpark.piraterobot.generator

import java.util.List
import org.codingpark.piraterobot.play.Action
import org.codingpark.piraterobot.play.PlayModel
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class PlayGenerator implements IGenerator {

	val String indentation = "	"
	val String lineSeparator = "\n"

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val playModel = resource.contents.head as PlayModel
		fsa.generateFile("levelAnimation.json", animation(playModel))
	}

	def TreeAppendable createAppendable(EObject context) {
		val appendable = new TreeAppendable(context, indentation, lineSeparator)
		return appendable
	}

	def CharSequence animation(PlayModel model) {
		val appendable = createAppendable(model)
		fileHeader(appendable)
		if (model != null && !model.procedures.empty) {
			fileActions(appendable, model.procedures.get(0).actions)
		}
		fileFooter(appendable)
		return appendable.content
	}

	def void fileHeader(ITreeAppendable appendable) {
		appendable.append("{\"animation\":[")
	}

	def void fileActions(ITreeAppendable appendable, List<Action> actions) {
		// counter to avoid long actions, e.g. up(16) down(16) etc.
		var int actionsCounter = 0
		var int x = 0
		while (x < actions.size && actionsCounter < 100) {
			var Action a = actions.get(x);
			x++;
			// parameter value, default is 1 if null
			var int parameterValue = 1;
			if(a.parameterValue != null){
				parameterValue = a.parameterValue.num;
			}
			if (a.isRepeat) {
				for (int i : 1 .. parameterValue) {
					fileActions(appendable, a.actions)
					appendable.append(",")
				}
			} else {
				if (a.isUp) {
					for (int i : 1 .. parameterValue) {
						appendable.append("1")
						appendable.append(",")
						actionsCounter++
					}
				} else if (a.isRight) {
					for (int i : 1 .. parameterValue) {
						appendable.append("2")
						appendable.append(",")
						actionsCounter++
					}
				} else if (a.isDown) {
					for (int i : 1 .. parameterValue) {
						appendable.append("3")
						appendable.append(",")
						actionsCounter++
					}
				} else if (a.isLeft) {
					for (int i : 1 .. parameterValue) {
						appendable.append("4")
						appendable.append(",")
						actionsCounter++
					}
				} else if (a.isDig) {
					appendable.append("5")
					appendable.append(",")
					actionsCounter++
				} else if (a.isJump) {
					for (int i : 1 .. parameterValue) {
						appendable.append("6")
						appendable.append(",")
						actionsCounter++
					}
				} else if (a.isFight) {
					appendable.append("7")
					appendable.append(",")
					actionsCounter++
				}
			}
		}
		val value = (appendable as TreeAppendable).content
		val length = value.length
		if (value.lastIndexOf(",") == length - 1) {
			appendable.removeLast()
		}
	}

	def void fileFooter(ITreeAppendable appendable) {
		appendable.append("]}")
	}
}
